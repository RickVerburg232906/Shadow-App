<!doctype html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shadow Motorclub - Scannen & Handmatig</title>
    <style>
      html,body{height:100%;margin:0;background:#0b0c10}
      .app-splash{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:20000;background:#0b0c10}
      .splash-inner{width:92vw;text-align:center;padding:20px}
      .splash-logo{width:110px;height:auto;margin:0 auto 12px;display:block}
      .splash-progress{height:10px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;margin:10px 0}
      .splash-progress-bar{height:100%;background:linear-gradient(90deg,#3b82f6,#06b6d4);width:0%;transition:width .3s ease}
      
      /* Inklapbare pijl: links (ingeklapt) ‚Üí onder (uitgeklapt) */
      details summary .toggle-icon {
        transform: rotate(-90deg);
      }

      /* updateTodayButton moved into the module script; keeping styles only in this block */
      details[open] summary .toggle-icon {
        transform: rotate(0deg);
      }
      details summary::-webkit-details-marker {
        display: none;
      }
      details summary::marker {
        display: none;
      }
    </style>
    <link rel="stylesheet" href="/style.css">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/assets/logo_MC_nieuw_trans_300.gif">
    <meta name="theme-color" content="#0f172a">
  <!-- html5-qrcode is loaded dynamically only when needed (avoid double-loading) -->
  <!-- Chart.js is loaded dynamically by the stats page when needed -->
  <!-- Preload main module to warm the module graph (helps vite/multi-page module startup) -->
  <link rel="modulepreload" href="/src/main.js">
  </head>
  <body>
    <div id="appSplash" class="app-splash" aria-hidden="false">
      <div class="splash-inner">
        <img src="/assets/logo_MC_nieuw_trans_300.gif" alt="Shadow" class="splash-logo" />
        <div class="splash-title">Shadow Motorclub</div>
        <div class="splash-progress">
          <div class="splash-progress-bar" id="splashProgressBar" style="width:0%"></div>
        </div>
        <div class="splash-caption" id="splashCaption">Laden‚Ä¶</div>
      </div>
    </div>
    
    <header class="topbar" style="height:64px; position:relative;">
      <div style="display:flex; align-items:center; height:100%; padding:0 12px; width:100%;">
        <nav class="nav">
          <a href="index.html" class="tab">Lid</a>
          <a href="admin-scan.html" class="tab active">Inschrijftafel</a>
        </nav>
        <div style="margin-left:auto; display:flex; align-items:center;">
          <img id="clubLogo" src="/assets/logo_MC_nieuw_trans_300.gif" alt="Shadow Motorclub logo" style="height:100%; width:auto; object-fit:contain;" />
        </div>
      </div>
    </header>

    <main class="wrap">
      <div class="admin-nav-dropdown">
        <select id="adminNavSelect" class="admin-nav-select">
          <option value="admin-scan.html" selected>Inschrijftafel</option>
          <option value="admin-planning.html">Begin van het jaar</option>
          <option value="admin-passwords.html">Wachtwoorden</option>
          <option value="admin-stats.html">Ritten data</option>
          <option value="admin-lunch.html">Lunch inplannen</option>
                      <option value="admin-excel.html">Excel import / export</option>

          <option value="admin-dev.html">Dev</option>
        </select>
      </div>

              <!-- Lunch overzicht sectie -->
        <div class="card" id="cardLunchOverview" style="display: block !important;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <div>
              <h3 style="margin: 0;">Lunch overzicht</h3>
              <p id="lunchOverviewDateTitle" class="muted" style="margin: 4px 0 0 0; font-size: 14px;">Eerstvolgende rit: ‚Äî</p>
            </div>
          </div>
          <div class="row" style="margin: 8px 0 12px; gap: 8px; align-items: center; flex-wrap: wrap;">
            <span id="lunchOverviewStatus" class="muted"></span>
          </div>

          <div class="row" style="margin: 6px 0 10px;">
            <div class="kv">
              <div class="label">Aantal eters</div>
              <div id="lunchTotalEaters" class="value">‚Äî</div>
            </div>
          </div>

          <div>
            <h4 id="lunchChoiceCountsTitle" style="margin: 10px 0 6px;">Keuzes (aantal)</h4>
            <div id="lunchChoiceCounts" style="display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center;">
              <!-- Dynamisch gevuld -->
            </div>
          </div>
        </div>
        
      <section id="viewAdmin" class="view active">
        <div class="card" id="qrScanCard">
          <h3>QR code scannen</h3>
          <p class="muted">Gebruik de camera om QR-codes te scannen en direct gegevens te verwerken.</p>
          <div class="row" style="gap:12px; align-items:center;">
            <button id="adminScanStart" class="btn">üì∑ Start scanner</button>
            <button id="adminScanStop" class="btn btn-ghost">‚è∏Ô∏è Stop</button>
            <span id="adminQRStatus" class="status"></span>
          </div>
          <div id="adminQRReader" class="qr-reader" style="margin-top:12px;"></div>
          <div id="adminQRResult" class="muted" style="margin-top:8px;"></div>
        </div>

        <!-- Vervangen door exacte inschrijven-rit sectie van index.html -->
        <section id="landelijkeSignup" data-ride-signup="true">
          <div class="card" id="manualRideCard">
            <h1>Handmatig inschrijven</h1>
            <p class="hint">Zoek op achternaam of voornaam.</p>
            
            <div id="adminManualSearchMount"></div>
            <script type="module">
              import renderMemberSearchInput, { wireAutocomplete } from '/src/member-search-input.js';
                import { renderLunchChoice } from '/src/lunch-ui.js';
                import { renderYearhanger } from '/src/yearhanger-ui.js';
              // setSelectedDocFromEntry removed ‚Äî page will handle loading member data itself

              const mount = document.getElementById('adminManualSearchMount');
              const widget = renderMemberSearchInput(mount, { showButton: false, placeholder: 'Naam' });
              // When the input becomes empty, hide any mounted lunch widget for clarity
              document.addEventListener('member-search:input', (ev) => {
                try {
                  const val = ev && ev.detail && typeof ev.detail.value === 'string' ? ev.detail.value.trim() : '';
                  if (!val) {
                    try {
                      const lc = document.getElementById('lunchChoiceSection');
                      if (lc) {
                        try { if (typeof lc.setMember === 'function') lc.setMember(null); } catch(_) {}
                        try { lc.style.display = 'none'; } catch(_) {}
                      }
                      try { const yr = document.getElementById('yearhangerRow_local'); if (yr) yr.style.display = 'none'; } catch(_) {}
                    } catch(_) {}
                  }
                } catch (e) { console.error('member-search input handler (admin) failed', e); }
              });
              try { wireAutocomplete(widget, {
                  onSelected: async (memberId) => {
                      // When selecting in the Handmatig inschrijven mount, hide the
                      // past-rides list and render only the manual (inschrijven) UI.
                      try {
                        try { const pr = document.getElementById('pastRidesList'); if (pr) pr.innerHTML = ''; } catch(_) {}
                        try { const ps = document.getElementById('pastRidesStatus'); if (ps) ps.textContent = ''; } catch(_) {}
                        // Load lunch UI into the lunchChoiceSection and make it visible
                        try {
                          const lc = document.getElementById('lunchChoiceSection') || (function(){ const d = document.createElement('div'); d.id='lunchChoiceSection'; d.style.display='none'; d.style.marginTop='24px'; const parent = document.getElementById('manualRideCard') || document.body; parent.appendChild(d); return d; })();
                          let rc = null;
                          try {
                            rc = renderLunchChoice(lc, { persist: false });
                          } catch(_) {}
                          try { lc.style.display = 'block'; } catch(_) {}

                          // Ensure the jaarhanger is mounted directly under the lunch section
                          try {
                            let yr = document.getElementById('yearhangerRow_local');
                            if (!yr) {
                              yr = document.createElement('div');
                              yr.id = 'yearhangerRow_local';
                              yr.style.marginTop = '8px';
                              yr.style.display = 'none';
                              lc.parentNode.insertBefore(yr, lc.nextSibling);
                            }
                            try { renderYearhanger(yr); } catch(_) {}
                            // Ensure the main `#result` card is positioned immediately after the jaarhanger
                            try {
                              const resultEl = document.getElementById('result');
                              if (resultEl && yr && yr.parentNode) {
                                try { yr.parentNode.insertBefore(resultEl, yr.nextSibling); } catch(_) {}
                              }
                            } catch(_) {}
                            // Attach a listener (once) that shows the local jaarhanger when lunch completes
                            try {
                              if (!window.__yearhanger_lunch_listener) {
                                document.addEventListener('lunch:completed', (ev) => {
                                  try {
                                    const yrEl = document.getElementById('yearhangerRow_local');
                                    if (!yrEl) return;
                                    try { yrEl.style.display = 'block'; } catch(_) {}
                                    try { if (typeof ensureResultVisibleAndScroll === 'function') ensureResultVisibleAndScroll(); } catch(_) {}
                                  } catch (e) { console.error('yearhanger show failed on lunch completed', e); }
                                });
                                window.__yearhanger_lunch_listener = true;
                              }
                            } catch(_) {}
                          } catch(_) {}

                          // Finally bind the member to the lunch widget so its internal
                          // setMember can dispatch the completion event after the
                          // jaarhanger listener is registered. The jaarhanger and
                          // member-info will be shown only when `lunch:completed` fires.
                          try { if (rc && typeof rc.setMember === 'function') await rc.setMember(memberId); } catch(_) {}
                          try { window.__current_selected_member = memberId ? String(memberId) : null; } catch(_) {}
                        } catch(_) {}
                        // Do not auto-show earlier rides when selecting from the
                        // "Handmatig inschrijven" widget. The Past Rides section
                        // has its own search mount and should be used to show
                        // previous rides to avoid coupling the two flows.
                        if (typeof updateTodayButton === 'function') await updateTodayButton(memberId);
                      } catch (e) { console.error('admin manual select handling failed', e); }
                    }
                }); } catch(e) { console.error('failed to wire autocomplete', e); }
            </script>
            
            <!-- Suggestions removed (centralized search will be provided later) -->
            <div id="error" class="error" style="display:none"></div>
            <div id="loadingIndicator" class="loading-indicator" style="display:none;">
              <div class="spinner"></div>
              <span class="loading-text">Gegevens laden...</span>
            </div>
            <div id="result" class="result" style="display:none">
              <div id="memberInfoMount"></div>
              <div id="manualTodayWrap" style="display:flex; gap:8px; align-items:center;">
                <button id="manualTodayBtn" class="btn" type="button">Vandaag</button>
                <span id="manualTodayStatus" class="muted small" aria-live="polite"></span>
              </div>
            </div>
            <script type="module">
              import renderMemberInfo from '/src/member-info.js';
              import { renderYearhanger } from '/src/yearhanger-ui.js';
              // mount once and expose for other scripts
              try {
                const mount = document.getElementById('memberInfoMount');
                window.__memberInfo = renderMemberInfo(mount);
              } catch (e) { console.error('member-info mount failed', e); }
              // Don't reveal member-info or jaarhanger immediately on selection;
              // only show them when the lunch flow reports completion.
              document.addEventListener('member-search:selected', (ev) => {
                try {
                  // selection is handled by the lunch widget (it will call rc.setMember)
                } catch (e) { console.error('member-info: selection handler suppressed', e); }
              });

              // When lunch completes for a member, reveal jaarhanger and member-info
              try {
                if (!window.__memberInfo_lunch_listener) {
                  document.addEventListener('lunch:completed', (ev) => {
                    try {
                      const memberId = ev && ev.detail && ev.detail.memberId ? String(ev.detail.memberId) : null;
                      if (!memberId) return;
                      // show yearhanger under lunch
                      try { const yrEl = document.getElementById('yearhangerRow_local'); if (yrEl) { yrEl.style.display = 'block'; } } catch(_) {}

                      // Defer revealing `member-info` until the jaarhanger value
                      // is available (via prefill or a `yearhanger:changed` event).
                      // Mark the member as pending so the persistent handler can
                      // show it once jaarhanger is set.
                      try { window.__pending_show_after_yearhanger = memberId; } catch(_) {}
                      // Register a persistent jaarhanger listener and prefilling flow
                      // similar to `index.html` to control result visibility.
                      try {
                        try { window.__current_selected_member = window.__current_selected_member || null; } catch(_) {}
                        try { window.__lunch_completed_members = window.__lunch_completed_members || new Set(); } catch(_) {}
                        // mark this member as having completed lunch
                        try { window.__lunch_completed_members.add(memberId); } catch(_) {}

                        const onYearChangedPersistent = (yEv) => {
                          try {
                            const val = yEv && yEv.detail && yEv.detail.value ? yEv.detail.value : null;
                            const evMember = yEv && yEv.detail && yEv.detail.memberId ? String(yEv.detail.memberId) : null;
                            const current = window.__current_selected_member ? String(window.__current_selected_member) : null;
                            const memberToCheck = evMember || current;
                            if (memberToCheck && window.__lunch_completed_members && window.__lunch_completed_members.has(memberToCheck)) {
                              try { const yrEl = document.getElementById('yearhangerRow_local') || document.getElementById('yearhangerRow'); const result = document.getElementById('result'); if (yrEl && result && yrEl.parentNode) yrEl.parentNode.insertBefore(result, yrEl.nextSibling); } catch(_) {}
                              try { if (window.__memberInfo && typeof window.__memberInfo.setMember === 'function') window.__memberInfo.setMember(memberToCheck); } catch(_) {}
                              try { if (typeof ensureResultVisibleAndScroll === 'function') ensureResultVisibleAndScroll(); } catch(_) {}
                            }
                          } catch (e) { console.error('admin-scan yearhanger:changed persistent handler failed', e); }
                        };
                        document.addEventListener('yearhanger:changed', onYearChangedPersistent);

                        // Prefill jaarhanger from Firestore (may dispatch prefill events)
                        try { renderYearhanger.setMember(memberId); } catch(_) {}

                        // Fallback: if jaarhanger already had a value, ensure member-info is shown
                        try {
                          const current = (renderYearhanger && typeof renderYearhanger.getValue === 'function') ? renderYearhanger.getValue() : null;
                          if (current) {
                            try { if (window.__memberInfo && typeof window.__memberInfo.setMember === 'function') window.__memberInfo.setMember(memberId); } catch(_) {}
                            try { if (typeof ensureResultVisibleAndScroll === 'function') ensureResultVisibleAndScroll(); } catch(_) {}
                          }
                        } catch(_) {}
                      } catch (e) { console.error('yearhanger prefill wiring failed', e); }
                    } catch (e) { console.error('lunch:completed handler failed', e); }
                  });
                  window.__memberInfo_lunch_listener = true;
                }
              } catch(_) {}
            </script>
          </div>
        </section>

        <div class="card" id="cardPastRidesRegister">
          <div>
            <h1>Eerdere ritten registreren</h1>
            <p class="hint">Selecteer een deelnemer en boek eerdere ritten.</p>
          </div>
          <script type="module">
            import renderMemberSearchInput, { wireAutocomplete } from '/src/member-search-input.js';
            // renderManualPastRides and updateTodayButton are defined in this page's script

            const pmMount = document.getElementById('pastRidesSearchMount');
            const pmWidget = renderMemberSearchInput(pmMount, { showButton: false, placeholder: 'Naam' });
            try { wireAutocomplete(pmWidget, {
                onSelected: async (memberId) => {
                  try {
                    // When selecting in the Past Rides mount, hide the manual
                    // inschrijven list and render only the past-rides UI.
                    try { const ml = document.getElementById('manualPastRidesList'); if (ml) ml.innerHTML = ''; } catch(_) {}
                    try { const ms = document.getElementById('manualPastRidesStatus'); if (ms) ms.textContent = ''; } catch(_) {}
                    if (typeof window.renderManualPastRides === 'function') await window.renderManualPastRides(memberId, { listId: 'pastRidesList', statusId: 'pastRidesStatus' });
                    if (typeof updateTodayButton === 'function') await updateTodayButton(memberId);
                  } catch (e) {
                    console.error('past rides select failed', e);
                  }
                }
            }); } catch(e) { console.error('failed to wire autocomplete', e); }
          </script>
          <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap;">
            <div id="pastRidesSearchMount" style="flex: 1; min-width: 240px;"></div>
            <span id="pastRidesLoading" class="muted" style="display:none">Laden‚Ä¶</span>
            <span id="pastRidesError" class="muted" style="display:none"></span>
          </div>
          <div id="pastRidesList" class="muted" style="margin-top:12px; display:grid; gap:8px;"></div>
          <div id="pastRidesStatus" class="small muted" style="min-height:18px;"></div>
        </div>

      </section>
    </main>

    <div id="toast-root" aria-live="polite" aria-atomic="true"></div>

    <script type="module">
      import { applyAdminLevel } from './src/main.js';
  import { getPlannedDates } from './src/member.js';
  import { plannedStarsWithHighlights } from './src/planned-stars.js';
  import { db, collection, orderBy, startAfter, limit, getDocs, query, onSnapshot, where } from './src/firebase.js';
      
      // Dropdown navigation handler
      const navSelect = document.getElementById('adminNavSelect');
      if (navSelect) {
        navSelect.addEventListener('change', (e) => {
          window.location.href = e.target.value;
        });
      }

      // Apply admin level restrictions after DOM is ready (auth gating removed)
      setTimeout(() => { applyAdminLevel(); }, 100);

      // ===== Lunch overzicht (automatisch voor eerstvolgende rit) =====
      const lunchOverviewDateTitle = document.getElementById('lunchOverviewDateTitle');
      const lunchOverviewStatus = document.getElementById('lunchOverviewStatus');
      const lunchTotalEaters = document.getElementById('lunchTotalEaters');
      const lunchChoiceCounts = document.getElementById('lunchChoiceCounts');

      async function getNextPlannedRideYMD() {
        try {
          const planned = await getPlannedDates();
          const list = (Array.isArray(planned) ? planned : []).map(d => {
            if (typeof d === 'string' && /\d{4}-\d{2}-\d{2}/.test(d)) return d.slice(0,10);
            try {
              const dt = new Date(d);
              if (!isNaN(dt)) return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`;
            } catch(_) {}
            return '';
          }).filter(Boolean).sort();
          const today = new Date();
          const todayYMD = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
          // Kies de eerste datum die vandaag of later is
          const next = list.find(d => d >= todayYMD);
          return next || '';
        } catch (_) { return ''; }
      }

      async function computeLunchOverview() {
        try {
          if (lunchOverviewStatus) lunchOverviewStatus.textContent = 'Ritdatum ophalen‚Ä¶';
          const ymd = await getNextPlannedRideYMD();
          
          if (!ymd) {
            lunchTotalEaters.textContent = '‚Äî';
            lunchChoiceCounts.innerHTML = '';
            if (lunchOverviewDateTitle) lunchOverviewDateTitle.textContent = 'Geen eerstvolgende rit gepland';
            if (lunchOverviewStatus) lunchOverviewStatus.textContent = 'Geen toekomstige ritdatums';
            return;
          }
          
          // Toon de datum in de titel
          if (lunchOverviewDateTitle) lunchOverviewDateTitle.textContent = `Eerstvolgende rit: ${ymd}`;
          
          if (lunchOverviewStatus) lunchOverviewStatus.textContent = 'Tellen‚Ä¶';
          let totalYes = 0;
          const perChoice = new Map();

          let last = null;
          const pageSize = 400;
          while (true) {
            let qRef = null;
            if (last) {
              qRef = query(collection(db, 'members'), orderBy('__name__'), startAfter(last), limit(pageSize));
            } else {
              qRef = query(collection(db, 'members'), orderBy('__name__'), limit(pageSize));
            }
            const snap = await getDocs(qRef);
            if (snap.empty) break;

            snap.forEach(docSnap => {
              const d = docSnap.data() || {};
              const deel = (d.lunchDeelname || '').toString().toLowerCase();
              const dateMatch = (d.lunchRideDateYMD || '').toString().slice(0,10) === ymd;
              if (deel === 'ja' && dateMatch) {
                totalYes++;
                const keuzeRaw = (d.lunchKeuze || '').toString().trim();
                const key = keuzeRaw || 'Geen keuze';
                perChoice.set(key, (perChoice.get(key) || 0) + 1);
              }
            });

            last = snap.docs[snap.docs.length - 1];
            if (snap.size < pageSize) break;
          }

          // Render
          lunchTotalEaters.textContent = String(totalYes);
          lunchChoiceCounts.innerHTML = '';
          
          // Check of er alleen "Geen keuze" is (betekent: geen keuze-eten beschikbaar)
          const onlyNoChoice = perChoice.size === 1 && perChoice.has('Geen keuze');
          const lunchChoiceCountsTitle = document.getElementById('lunchChoiceCountsTitle');
          
          if (onlyNoChoice) {
            // Verberg de hele keuzes sectie als er alleen "Geen keuze" is
            if (lunchChoiceCountsTitle) lunchChoiceCountsTitle.style.display = 'none';
            lunchChoiceCounts.style.display = 'none';
          } else {
            // Toon de keuzes sectie
            if (lunchChoiceCountsTitle) lunchChoiceCountsTitle.style.display = 'block';
            lunchChoiceCounts.style.display = 'grid';
            
            if (perChoice.size === 0) {
              const empty = document.createElement('div');
              empty.className = 'muted';
              empty.style.gridColumn = '1 / -1';
              empty.textContent = 'Geen keuzes gevonden voor deze datum.';
              lunchChoiceCounts.appendChild(empty);
            } else {
              const entries = Array.from(perChoice.entries()).sort((a,b) => a[0].localeCompare(b[0]));
              for (const [name, count] of entries) {
                const l = document.createElement('div');
                l.textContent = name;
                const v = document.createElement('div');
                v.className = 'value';
                v.textContent = String(count);
                lunchChoiceCounts.appendChild(l);
                lunchChoiceCounts.appendChild(v);
              }
            }
          }
          if (lunchOverviewStatus) {
            // We're done loading ‚Äî clear status immediately so nothing remains visible.
            if (lunchOverviewStatus._fadeTimer) {
              clearTimeout(lunchOverviewStatus._fadeTimer);
              lunchOverviewStatus._fadeTimer = null;
            }
            lunchOverviewStatus.textContent = '';
            lunchOverviewStatus.style.transition = '';
            lunchOverviewStatus.style.opacity = '';
          }

          // Store current overview state so live updates can apply deltas instead of re-scanning
          try {
            const memberState = new Map(); // memberId -> { deel, keuze, date }
            // Build a baseline memberState by doing a single-pass query for members on this date.
            (async () => {
              try {
                const ms = new Map();
                let last2 = null;
                const pageSize2 = 400;
                while (true) {
                  let qRef2 = null;
                  if (last2) {
                    qRef2 = query(collection(db, 'members'), orderBy('__name__'), startAfter(last2), limit(pageSize2));
                  } else {
                    qRef2 = query(collection(db, 'members'), orderBy('__name__'), limit(pageSize2));
                  }
                  const snap2 = await getDocs(qRef2);
                  if (snap2.empty) break;
                  snap2.forEach(docSnap => {
                    const d = docSnap.data() || {};
                    const dateMatch = (d.lunchRideDateYMD || '').toString().slice(0,10) === ymd;
                    if (dateMatch) {
                      const deel = (d.lunchDeelname || '').toString().toLowerCase();
                      const keuze = (d.lunchKeuze || '').toString().trim();
                      ms.set(docSnap.id, { deel, keuze, date: ymd });
                    }
                  });
                  last2 = snap2.docs[snap2.docs.length - 1];
                  if (snap2.size < pageSize2) break;
                }
                window.__lunchOverview = { ymd, hasChoices, totalYes, perChoiceMap: perChoice, memberState: ms };
              } catch (e) {
                console.debug('Failed to build memberState for lunch overview; live updates may be less accurate', e);
                window.__lunchOverview = { ymd, hasChoices, totalYes, perChoiceMap: perChoice, memberState: new Map() };
              }
            })();
          } catch (e) { /* ignore */ }

          // Determine if there are per-choice menu options (exclude single 'Geen keuze')
          const hasChoices = perChoice.size > 0 && !(perChoice.size === 1 && perChoice.has('Geen keuze'));
          // (Re)setup targeted live listener for this date and mode
          try { setupLunchLiveListener(ymd, hasChoices); } catch (e) { console.debug('setupLunchLiveListener failed', e); }
        } catch (e) {
          console.error('Overzicht tellen mislukt', e);
          if (lunchOverviewStatus) lunchOverviewStatus.textContent = '‚ùå Mislukt';
        }
      }

      // Init overview bij laden van de pagina
      computeLunchOverview();

      // --- Live listener wiring helper for the lunch overview ---
      function setupLunchLiveListener(ymd, hasChoices) {
        // Unsubscribe previous listener if present
        try { if (window.__unsubLunchOverview) { window.__unsubLunchOverview(); delete window.__unsubLunchOverview; } } catch (_) {}
        if (!ymd) return; // nothing to listen for

        // Build a targeted query: listen for any member assigned to this lunch date.
        // Use a date-only query so additions/changes to lunchDeelname or lunchKeuze
        // are always observed and the overview updates dynamically.
        const q = query(collection(db, 'members'), where('lunchRideDateYMD', '==', ymd));

        let debounce = null;
        // Helper to render perChoiceMap into the DOM
        function renderChoiceCounts(perChoiceMap) {
          try {
            lunchChoiceCounts.innerHTML = '';
            const onlyNoChoice = perChoiceMap.size === 1 && perChoiceMap.has('Geen keuze');
            if (onlyNoChoice) {
              if (lunchChoiceCountsTitle) lunchChoiceCountsTitle.style.display = 'none';
              lunchChoiceCounts.style.display = 'none';
              return;
            }
            if (lunchChoiceCountsTitle) lunchChoiceCountsTitle.style.display = 'block';
            lunchChoiceCounts.style.display = 'grid';
            if (perChoiceMap.size === 0) {
              const empty = document.createElement('div');
              empty.className = 'muted';
              empty.style.gridColumn = '1 / -1';
              empty.textContent = 'Geen keuzes gevonden voor deze datum.';
              lunchChoiceCounts.appendChild(empty);
              return;
            }
            const entries = Array.from(perChoiceMap.entries()).sort((a,b) => a[0].localeCompare(b[0]));
            for (const [name, count] of entries) {
              const l = document.createElement('div');
              l.textContent = name;
              const v = document.createElement('div');
              v.className = 'value';
              v.textContent = String(count);
              lunchChoiceCounts.appendChild(l);
              lunchChoiceCounts.appendChild(v);
            }
          } catch (e) { /* ignore render errors */ }
        }

        try {
          const unsub = onSnapshot(q, (snap) => {
            // If we don't have baseline state, fallback to full recompute
            const base = window.__lunchOverview;
            if (!base || !base.memberState) {
              if (debounce) clearTimeout(debounce);
              debounce = setTimeout(() => computeLunchOverview(), 300);
              return;
            }

            // Process doc changes incrementally
            let changed = false;
            for (const change of snap.docChanges()) {
              try {
                const id = change.doc.id;
                const d = change.doc.data() || {};
                const newDate = (d.lunchRideDateYMD || '').toString().slice(0,10);
                const newDeel = (d.lunchDeelname || '').toString().toLowerCase();
                const newKeuze = (d.lunchKeuze || '').toString().trim();

                const prev = base.memberState.get(id) || { deel: '', keuze: '', date: '' };

                // Case: document now belongs to this date but previously didn't -> added
                if (newDate === base.ymd && prev.date !== base.ymd) {
                  // Added into this date
                  if (newDeel === 'ja') base.totalYes += 1;
                  // increment perChoice if applicable
                  const key = newKeuze || 'Geen keuze';
                  base.perChoiceMap.set(key, (base.perChoiceMap.get(key) || 0) + 1);
                  base.memberState.set(id, { deel: newDeel, keuze: newKeuze, date: base.ymd });
                  changed = true;
                  continue;
                }

                // Case: document left this date -> removed
                if (prev.date === base.ymd && newDate !== base.ymd) {
                  if (prev.deel === 'ja') base.totalYes = Math.max(0, base.totalYes - 1);
                  const prevKey = prev.keuze || 'Geen keuze';
                  base.perChoiceMap.set(prevKey, Math.max(0, (base.perChoiceMap.get(prevKey) || 1) - 1));
                  if (base.perChoiceMap.get(prevKey) === 0) base.perChoiceMap.delete(prevKey);
                  base.memberState.delete(id);
                  changed = true;
                  continue;
                }

                // Case: document remained on this date -> modified
                if (prev.date === base.ymd && newDate === base.ymd) {
                  // deel change
                  if (prev.deel !== newDeel) {
                    if (prev.deel === 'ja') base.totalYes = Math.max(0, base.totalYes - 1);
                    if (newDeel === 'ja') base.totalYes += 1;
                    prev.deel = newDeel;
                    changed = true;
                  }
                  // keuze change
                  if ((prev.keuze || '') !== (newKeuze || '')) {
                    const prevKey = (prev.keuze || 'Geen keuze');
                    base.perChoiceMap.set(prevKey, Math.max(0, (base.perChoiceMap.get(prevKey) || 1) - 1));
                    if (base.perChoiceMap.get(prevKey) === 0) base.perChoiceMap.delete(prevKey);
                    const newKey = (newKeuze || 'Geen keuze');
                    base.perChoiceMap.set(newKey, (base.perChoiceMap.get(newKey) || 0) + 1);
                    prev.keuze = newKeuze;
                    changed = true;
                  }
                  base.memberState.set(id, prev);
                  continue;
                }
              } catch (e) {
                console.debug('Error processing lunch doc change', e);
              }
            }

            if (changed) {
              // Update DOM with new totals
              lunchTotalEaters.textContent = String(window.__lunchOverview.totalYes);
              renderChoiceCounts(window.__lunchOverview.perChoiceMap);
            }
          }, (err) => {
            console.warn('Lunch live snapshot error', err);
          });
          window.__unsubLunchOverview = unsub;
        } catch (e) {
          console.debug('Failed to attach lunch live snapshot', e);
        }
      }
      // Init overview bij laden van de pagina
      // (computeLunchOverview will call setupLunchLiveListener with the correct date/mode)
      // computeLunchOverview(); already called above
    </script>
    
    <script type="module">
      // Handmatig boeken voor de leden-inschrijfsectie (vervangt QR in admin-scan)
  import { getPlannedDates } from './src/member.js';
  import { plannedStarsWithHighlights } from './src/planned-stars.js';
  import { db, doc, getDoc, arrayUnion, runTransaction, increment, collection, query, orderBy, startAfter, limit, getDocs } from './src/firebase.js';
  import { withRetry, updateOrCreateDoc } from './src/firebase-helpers.js';

      function toYMD(d) {
        try {
          // Support raw strings like '2025-11-16', Date objects, and Firestore Timestamps
          if (d && typeof d.toDate === 'function') {
            // Firestore Timestamp
            d = d.toDate();
          }
          if (typeof d === 'string' && /\d{4}-\d{2}-\d{2}/.test(d)) return d.slice(0,10);
          const dt = new Date(d);
          if (!isNaN(dt)) return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`;
          return '';
        } catch { return ''; }
      }
      function formatDateNL(ymd) {
        try {
          const [y,m,d] = [ymd.slice(0,4), ymd.slice(5,7), ymd.slice(8,10)];
          const dt = new Date(Number(y), Number(m)-1, Number(d));
          return dt.toLocaleDateString('nl-NL', { day:'2-digit', month:'long', year:'numeric' });
        } catch { return ymd; }
      }

      // Update the Today quick-book button to reflect whether 'today' is already registered
      async function updateTodayButton(memberId) {
        const btn = document.getElementById('manualTodayBtn');
        const statusEl = document.getElementById('manualTodayStatus');
        if (!btn) return;
        const today = new Date();
        const todayYMD = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
        const titleLabel = formatDateNL(todayYMD);

        // If no member selected, reset the button to default
        if (!memberId || memberId === '‚Äî') {
          try { btn.disabled = false; btn.removeAttribute('aria-disabled'); btn.classList.remove('btn-error'); btn.textContent = 'Vandaag'; btn.title = ''; if (statusEl) statusEl.textContent = ''; } catch(_) {}
          return;
        }

        try {
          const snap = await getDoc(doc(db, 'members', String(memberId)));
          if (!snap.exists()) {
            try { btn.disabled = false; btn.removeAttribute('aria-disabled'); btn.textContent = 'Vandaag'; btn.title = titleLabel; } catch(_) {}
            return;
          }
          const d = snap.data() || {};
          const existing = new Set((Array.isArray(d.ScanDatums) ? d.ScanDatums : []).map(toYMD).filter(Boolean));
          if (existing.has(todayYMD)) {
            // Already registered: show registered appearance and disable button
            try {
              btn.classList.remove('btn-error');
              btn.textContent = `‚úÖ Vandaag ‚Äî geregistreerd`;
              btn.disabled = true;
              btn.setAttribute('aria-disabled', 'true');
              btn.title = titleLabel;
            } catch(_) {}
          } else {
            // Not registered: ensure the button is enabled and shows 'Vandaag'
            try { btn.classList.remove('btn-error'); btn.disabled = false; btn.removeAttribute('aria-disabled'); btn.textContent = 'Vandaag'; btn.title = titleLabel; } catch(_) {}
          }
        } catch (e) {
          console.error('updateTodayButton failed', e);
        }
      }

      async function renderManualPastRides(memberId, opts = {}) {
        // The template historically used `manualPastRidesList`/`manualPastRidesStatus`.
        // Some pages use `pastRidesList`/`pastRidesStatus` instead. Prefer explicit
        // opts, then fall back to whichever element exists in the DOM.
        const listId = opts.listId || (document.getElementById('manualPastRidesList') ? 'manualPastRidesList' : 'pastRidesList');
        const statusId = opts.statusId || (document.getElementById('manualPastRidesStatus') ? 'manualPastRidesStatus' : 'pastRidesStatus');
        const listEl = document.getElementById(listId);
        const statusEl = document.getElementById(statusId);
        if (!listEl) return;

        // Prevent duplicate immediate renders: if we've just rendered for the
        // same member within the last 800ms, skip. This avoids double output
        // when multiple listeners trigger rendering (selection + mutation observer).
        const now = Date.now();
        if (renderManualPastRides._lastMemberId === memberId && (now - (renderManualPastRides._lastAt || 0) < 800)) return;
        renderManualPastRides._lastMemberId = memberId;
        renderManualPastRides._lastAt = now;

        listEl.innerHTML = '';
        if (statusEl) statusEl.textContent = '';

        try {
          const planned = await getPlannedDates();
          const today = new Date();
          const todayYMD = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
          const past = (Array.isArray(planned) ? planned : [])
            .map(toYMD)
            .filter(Boolean)
            .filter(d => d < todayYMD)
            .sort((a,b) => b.localeCompare(a));

          if (!past.length) {
            const empty = document.createElement('div');
            empty.className = 'muted';
            empty.textContent = 'Er zijn nog geen eerdere ritten.';
            listEl.appendChild(empty);
            return;
          }

          // Haal huidige ScanDatums op zodat we knoppen kunnen disablen waar nodig
          let existing = new Set();
          try {
            const snap = await getDoc(doc(db, 'members', String(memberId)));
            if (snap.exists()) {
              const data = snap.data() || {};
              existing = new Set((Array.isArray(data.ScanDatums) ? data.ScanDatums : []).map(toYMD).filter(Boolean));
            }
          } catch(_) {}

          past.forEach(ymd => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn';
            btn.dataset.ymd = ymd;

            const label = formatDateNL(ymd);
            if (existing.has(ymd)) {
              btn.textContent = `‚úÖ ${label} ‚Äî geregistreerd`;
              btn.disabled = true;
              btn.setAttribute('aria-disabled', 'true');
              btn.title = label;
            } else {
              btn.textContent = label;
            }

            btn.addEventListener('click', async () => {
                try {
                  btn.disabled = true;
                  btn.textContent = `${label} ‚Ä¢ opslaan‚Ä¶`;

                  await withRetry(() => runTransaction(db, async (tx) => {
                    const mRef = doc(db, 'members', String(memberId));
                    const snapCur = await tx.get(mRef);
                    if (snapCur.exists()) {
                      const dcur = snapCur.data() || {};
                      const existing = new Set((Array.isArray(dcur.ScanDatums) ? dcur.ScanDatums : []).map(toYMD).filter(Boolean));
                      if (existing.has(ymd)) { return; }
                      tx.update(mRef, { ScanDatums: arrayUnion(ymd) });
                    } else {
                      tx.set(mRef, { ScanDatums: [ymd] });
                    }
                  }), { retries: 3 });

                  btn.textContent = `‚úÖ ${label} ‚Äî geregistreerd`;
                  btn.title = label;
                  existing.add(ymd);
                } catch (e) {
                  console.error('Handmatig boeken mislukt', e);
                  btn.disabled = false;
                  btn.textContent = label;
                  if (statusEl) statusEl.textContent = '‚ùå Opslaan mislukt. Controleer je verbinding of rechten.';
                }
            });

            listEl.appendChild(btn);
          });

          // Alleen de Today button bij de leden-inschrijfsectie bijwerken (oude plek)
          if (listId === 'manualPastRidesList') {
            try { await updateTodayButton(memberId); } catch(_) {}
          }
        } catch (e) {
          console.error('Past rides render failed', e);
          if (statusEl) statusEl.textContent = '‚ùå Ritten laden mislukt.';
        }
      }

      // Expose for other module scripts to reuse
      try { window.renderManualPastRides = renderManualPastRides; } catch(_) {}

      // Global member selection handler removed: each search mount handles
      // its own selection and hides the other section to remain mutually exclusive.

      // Clear past-rides and result UI when the search input is cleared
      try {
        document.addEventListener('member-search:input', (ev) => {
          try {
            const val = (ev && ev.detail && typeof ev.detail.value === 'string') ? ev.detail.value.trim() : '';
            if (val) return; // only act when input is empty
            const listIds = ['manualPastRidesList', 'pastRidesList'];
            const statusIds = ['manualPastRidesStatus', 'pastRidesStatus'];
            listIds.forEach(id => { const el = document.getElementById(id); if (el) el.innerHTML = ''; });
            statusIds.forEach(id => { const s = document.getElementById(id); if (s) s.textContent = ''; });
            // Hide result card and reset summary fields
            try { const resultEl = document.getElementById('result'); if (resultEl) resultEl.style.display = 'none'; } catch(_) {}
            try { const rn = document.getElementById('rName'); if (rn) rn.textContent = '‚Äî'; } catch(_) {}
            try { const rno = document.getElementById('rMemberNo'); if (rno) rno.textContent = '‚Äî'; } catch(_) {}
          } catch (e) { console.error('member-search:input handler error', e); }
        });
      } catch(_) {}

      // Observeer wijzigingen aan de leden-inschrijfsectie en render past rides bij selectie
      const resultEl = document.getElementById('result');
      const memberNoEl = document.getElementById('rMemberNo');
      let lastMemberId = '';

      async function maybeRender() {
        const id = (memberNoEl?.textContent || '').trim();
        // Als er geen geldige selectie is, verberg het resultaatkader
        if (!id || id === '‚Äî') {
          if (resultEl) resultEl.style.display = 'none';
          return;
        }
        if (id === lastMemberId) return;
        lastMemberId = id;
        // Geldige selectie: toon resultaat en render lijst
        if (resultEl) { resultEl.style.display = 'grid'; resultEl.style.visibility = ''; }
        // Render past rides and update the Today button state asynchronously
        try { await renderManualPastRides(id); } catch(_) {}
        try { await updateTodayButton(id); } catch(_) {}
      }

        if (resultEl && memberNoEl) {
        const mo = new MutationObserver(() => {
          // Reageer op wijzigingen en bepaal zichtbaar/verborgen op basis van selectie
          maybeRender();
        });
        mo.observe(resultEl, { attributes: true, childList: true, subtree: true, characterData: true });
        // Eerste poging ook direct
        setTimeout(() => maybeRender(), 300);

        // Wire the "Vandaag" quick-book button: checks planned dates and books today atomically
        (function wireTodayButton() {
          const btn = document.getElementById('manualTodayBtn');
          const statusEl = document.getElementById('manualTodayStatus');
          if (!btn) return;
          btn.addEventListener('click', async () => {
            let origText = btn.textContent;
            try {
              if (statusEl) statusEl.textContent = '';
              const memberId = (memberNoEl?.textContent || '').trim();
              if (!memberId || memberId === '‚Äî') { if (statusEl) statusEl.textContent = 'Kies eerst een lid.'; return; }
              const today = new Date();
              const todayYMD = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
              // Precompute the human label so Today matches past-ride button labels
              const label = formatDateNL(todayYMD);

              // Ensure today is a planned ride date
              const planned = await getPlannedDates();
              const plannedYMDs = (Array.isArray(planned) ? planned.map(toYMD).filter(Boolean) : []);
                if (!plannedYMDs.includes(todayYMD)) {
                // Show the message directly in the Today button and make it red for a short cooldown
                try {
                  const msg = 'Vandaag is geen geplande ritdatum.';
                  // Set visible text and error styling. Don't set disabled/aria-disabled here because
                  // selectors targeting [disabled] or [aria-disabled] force the green registered style.
                  btn.textContent = msg;
                  btn.classList.add('btn-error');
                  // Make non-interactive via CSS (pointer-events) so it behaves like disabled without triggering green styles
                  if (statusEl) statusEl.textContent = '';
                  // Ensure we don't stack multiple timers
                  try { if (btn.__clearErrorTimeout) { clearTimeout(btn.__clearErrorTimeout); delete btn.__clearErrorTimeout; } } catch(_) {}
                  // Clear the red visual after 2 seconds
                  try {
                    btn.__clearErrorTimeout = setTimeout(() => {
                      try { btn.classList.remove('btn-error'); btn.textContent = 'Vandaag'; } catch(_) {}
                      try { delete btn.__clearErrorTimeout; } catch(_) {}
                    }, 2000);
                  } catch(_) {}
                } catch(_) {}
                return;
              }

              // Check quickly if already registered -> if so, show the registered state
              try {
                const snapCheck = await getDoc(doc(db, 'members', String(memberId)));
                if (snapCheck.exists()) {
                  const dcur = snapCheck.data() || {};
                  const existing = new Set((Array.isArray(dcur.ScanDatums) ? dcur.ScanDatums : []).map(toYMD).filter(Boolean));
                  if (existing.has(todayYMD)) {
                    // Show registered state on the button (green) and keep title as the actual date
                    // Use "Vandaag" in the visible label so it's clear which button is today
                    btn.textContent = `‚úÖ Vandaag ‚Äî geregistreerd`;
                    btn.disabled = true;
                    btn.setAttribute('aria-disabled', 'true');
                    btn.title = label;
                    // Refresh small bits
                    try { renderManualPastRides(memberId); } catch(_) {}
                    // Update rides display using the same stars renderer as elsewhere
                    try {
                      if (rRidesEl) {
                        const scanDates = Array.isArray(dcur.ScanDatums) ? dcur.ScanDatums : [];
                        const { starsHtml, tooltip, planned: plannedNorm } = plannedStarsWithHighlights(planned, scanDates);
                        rRidesEl.innerHTML = starsHtml || '‚Äî';
                        rRidesEl.setAttribute('title', starsHtml ? tooltip : 'Geen ingeplande datums');
                        rRidesEl.setAttribute('aria-label', starsHtml ? `Sterren per datum (gepland: ${plannedNorm.length})` : 'Geen ingeplande datums');
                        rRidesEl.style.letterSpacing = '3px';
                        rRidesEl.style.fontSize = '20px';
                      }
                    } catch(_) {}
                    return;
                  }
                }
              } catch (e) {
                // ignore check error and proceed to attempt transaction
              }

              btn.disabled = true;
              // Use the localized word 'Vandaag' during save so the button clearly represents today
              btn.textContent = `Vandaag ‚Ä¢ opslaan‚Ä¶`;

              // Collect lunch + jaarhanger UI values so we can save them atomically with the scan
              try {
                const lunchYesEl = document.getElementById('lunchYes');
                const lunchNoEl = document.getElementById('lunchNo');
                const lunchDeelname = (lunchYesEl && lunchYesEl.classList.contains('active')) ? 'ja'
                                    : (lunchNoEl && lunchNoEl.classList.contains('active')) ? 'nee'
                                    : null;
                let lunchKeuze = null;
                const keuzeWrap = document.getElementById('keuzeEtenButtons');
                if (keuzeWrap) {
                  const activeBtn = keuzeWrap.querySelector('button.active');
                  if (activeBtn) lunchKeuze = (activeBtn.textContent || '').trim();
                }
                const yYes = document.getElementById('yearhangerYes');
                const yNo = document.getElementById('yearhangerNo');
                const jaarVal = (yYes && yYes.classList.contains('active')) ? 'Ja' : (yNo && yNo.classList.contains('active')) ? 'Nee' : null;

                  await withRetry(() => runTransaction(db, async (tx) => {
                  const mRef = doc(db, 'members', String(memberId));
                  const snapCur = await tx.get(mRef);
                  const toWrite = { ScanDatums: arrayUnion(todayYMD) };
                  // Attach lunch/yearhanger values when present (null means no selection)
                  if (lunchDeelname !== null) toWrite.lunchDeelname = lunchDeelname;
                  if (lunchKeuze !== null) toWrite.lunchKeuze = lunchKeuze;
                  if (jaarVal !== null) toWrite.Jaarhanger = jaarVal;
                  // Save the ride date for the lunch selection
                  toWrite.lunchRideDateYMD = todayYMD;

                  if (snapCur.exists()) {
                    const dcur = snapCur.data() || {};
                    const existing = new Set((Array.isArray(dcur.ScanDatums) ? dcur.ScanDatums : []).map(toYMD).filter(Boolean));
                    if (existing.has(todayYMD)) {
                      // nothing to do for scan date, but still merge in lunch/yearhanger if provided
                      // update only the additional fields
                      const updateFields = Object.assign({}, toWrite);
                      // Remove ScanDatums since already present
                      delete updateFields.ScanDatums;
                      if (Object.keys(updateFields).length) tx.update(mRef, updateFields);
                      return;
                    }
                    tx.update(mRef, toWrite);
                  } else {
                    // New doc: include the fields and arrays
                    const base = { ScanDatums: [todayYMD] };
                    tx.set(mRef, Object.assign(base, toWrite));
                  }
                }), { retries: 3 });
              } catch (e) {
                // If collecting UI values or transaction fails, rethrow to outer catch
                throw e;
              }

              // Success: set registered appearance (show green check + text)
              // Show "Vandaag" for clarity instead of the full date
              btn.textContent = `‚úÖ Vandaag ‚Äî geregistreerd`;
              btn.disabled = true;
              btn.setAttribute('aria-disabled', 'true');
              btn.title = label;

              // Refresh past rides list and rides count
              try { renderManualPastRides(memberId); } catch(_) {}
              try {
                const snap = await getDoc(doc(db, 'members', String(memberId)));
                if (snap.exists()) {
                  const d = snap.data() || {};
                  try {
                    if (rRidesEl) {
                      const scanDates = Array.isArray(d.ScanDatums) ? d.ScanDatums : [];
                      const { starsHtml, tooltip, planned: plannedNorm } = plannedStarsWithHighlights(planned, scanDates);
                      rRidesEl.innerHTML = starsHtml || '‚Äî';
                      rRidesEl.setAttribute('title', starsHtml ? tooltip : 'Geen ingeplande datums');
                      rRidesEl.setAttribute('aria-label', starsHtml ? `Sterren per datum (gepland: ${plannedNorm.length})` : 'Geen ingeplande datums');
                      rRidesEl.style.letterSpacing = '3px';
                      rRidesEl.style.fontSize = '20px';
                    }
                  } catch(_) {}
                }
              } catch(_) {}

            } catch (e) {
              console.error('Handmatig boeken vandaag mislukt', e);
              if (statusEl) statusEl.textContent = '‚ùå Opslaan mislukt.';
              try { btn.disabled = false; btn.textContent = origText; } catch(_) {}
            }
          });
        })();
      }

      // Zorg dat na keuze Jaarhanger de gegevens-sectie in beeld komt
      function ensureResultVisibleAndScroll() {
        const id = (memberNoEl?.textContent || '').trim();
        if (!id || id === '‚Äî') return; // geen selectie, niets tonen
        if (resultEl) {
          resultEl.style.display = 'grid';
          resultEl.style.visibility = '';
          // Laat de browser eerst lay-outen en scroll dan vloeiend in beeld
          setTimeout(() => {
            try { resultEl.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch {}
          }, 50);
        }
      }

      // Exposeer deze helper globaal zodat andere modules (zoals member.js) hem kunnen aanroepen
      try { if (typeof window !== 'undefined') window.ensureResultVisibleAndScroll = ensureResultVisibleAndScroll; } catch(_) {}

      const yhYes = document.getElementById('yearhangerYes');
      const yhNo = document.getElementById('yearhangerNo');
      yhYes?.addEventListener('click', ensureResultVisibleAndScroll);
      yhNo?.addEventListener('click', ensureResultVisibleAndScroll);
      // When lunch choices are already complete for the selected member, ensure result and jaarhanger are visible
      try { document.addEventListener('lunch:completed', () => { try { ensureResultVisibleAndScroll(); } catch(_) {} }); } catch(_) {}

      // (Replaced dropdown population with autocomplete initialization below)
    </script>
    <!-- Member search initialization removed from admin-scan to decouple local input-driven queries -->
    
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
